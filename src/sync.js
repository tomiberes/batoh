/**
 * Batoh.js server sync.
 * Licensed under the MIT license
 * Copyright (c) 2014 Tomas Beres
 *
 * https://github.com/tomiberes/batoh
 *
 * Synchronize with the server. With some assumptions,
 * orchestrated by the client.
 *
 * Local records have to contain:
 *  `id` uuid for identification.
 *  `timestamp` initialy empty String, generated by the server on each sync.
 *  `dirty` marks if the record have been modified since last sync.
 *  `deleted` marks is the record have been deleted.
 *
 * Server have to respond on GET `url` + `?last_sync` with records
 *  which were changed since giver timestamp. The response have to contain
 *  `id`, `timestamp` and `deleted`.
 * Have to respond on each POST and PUT with JSON containing new timestamp.
 *
 * @param {String} setup - setup used to define configuration.
 * @param {String} store - name of the object store to use.
 * @param {Object} [options] - configuration Object.
 * @param {Function} [options.onComplete] - called when sync is completed
 * @param {Function} [options.onError] - called when error occurs,
 *  gets one argument an Error.
 * @param {Function} [options.resolveConflict] - custom conflict resolution,
 *  gets three arguments `localRecord` and `remoteRecord` which are in conflict.
 *  And `count` which have to be called once resolution is done,
 *  to keep track of the asynchronous operations.
 * @param {String} [options.url] - URL
 */

var sync = Batoh.sync = function(setup, store, options) {
  var db = new Batoh.Database(setup);
  var url = '/' + store || options.url;
  // Optional callbacks
  if (options.onComplete) syncComplete = options.onComplete;
  if (options.onError) handleError = options.onError;
  if (options.resolveConflict) resolveConflict = options.resolveConflict;
  var newRecords = [];
  var updatedRecords = [];

  // Initiate sync by fetching last sync timestamp from store
  getLastSync();

  function getLastSync(handleError) {
    // Get first highest record of `timestamp` from store
    var query = {
      index: 'timestamp',
      range: Batoh.IDBKeyRange.upperBound(Number.POSITIVE_INFINITY, true),
      direction: 'prev',
      limit: 1
    };
    db.open(function() {
      db.query(store, query, function(err, result) {
        if (err) handleError(err);
        // If there isn't any result set timestamp to 0,
        // fetch everything from the server
        var lastSync = result[0] ? result[0].timestamp : 0;
        db.close();
        // Continue with fetching remote records
        getRemoteRecords(lastSync);
      });
    });
  }

  // Assumed url, should be configurable
  // GET /notes?last_sync=`timestamp`
  function getRemoteRecords(lastSync) {
    var xhr = new XMLHttpRequest();
    var resp;
    xhr.open('GET', url + '?last_sync=' + lastSync, true);
    xhr.send();
    xhr.onload = function() {
      resp = this.response;
      var remoteRecords = JSON.parse(resp);
      // Continue with local update
      localUpdate(remoteRecords);
    };
    xhr.onerror = function(err) {
      handleError(err);
    };
  }

  function localUpdate(remoteRecords) {
    // If there no remote records have been fetched goes straight to `getDirtyRecords`
    var count = makeCounter(remoteRecords.length, db, getDirtyRecords);
    db.open(function() {
      if (err) return handleError(err);
      remoteRecords.forEach(function(remote, index, array) {
        db.get(store, remote.id, function(err, result) {
          var local = result[0];
          if (err) return handleError(err);
          if (local) {
            // Conflict
            if (local.dirty === true) {
              // Pass it to conflict resolution method
              resolveConflict(local, remote, count);
            // Deletted from different client
            } else if (remote.deleted === true) {
              db.delete(store, remote.id, function(err, result) {
                if (err) return handleError(err);
                count();
              });
            // Updated from diferrent client
            } else {
              db.put(store, remote, function(err, result) {
                if (err) return handleError(err);
                count();
              });
            }
          // New record
          } else {
            db.add(store, remote, function(err, result) {
              if (err) return handleError(err);
              count();
            });
          }
        });
      });
    });
  }

  function resolveConflict(localRecord, remoteRecord, count) {
    // TODO: no default
    count();
  }

  function getDirtyRecords() {
    var query = {
      index: 'timestamp',
      range: null,
      direction: 'next'
    };
    // `each` function for filtering the records inside IndexedDB query, see Batoh core docs
    var each = function(record) {
      // Only records which have been changed
      if (record.dirty === true) {
        // Records created on client and haven't been synced yet, thus no `timestamp`
        // Timestamp have to be empty string value, not `null` to be able to query it
        if (record.timestamp === '') {
          newRecords.push(record);
        // Records that have already been synced with the server and have a `timestamp`
        } else {
          updatedRecords.push(record);
        }
      }
    };
    // Perform the query on the store
    db.open(function() {
      db.query(store, query, each, function(err, result) {
        if (err) handleError(err);
        db.close();
        // Continue with remote update
        remoteUpdate();
      });
    });
  }

  function remoteUpdate() {
    // Create counter for updating records remotely and locally afterwards
    var count = makeCounter((newRecords.length + updatedRecords.length), null, syncComplete);
    if (newRecords.length > 0) {
      for (var i = 0; i < newRecords.length; i++) {
        postRecord(newRecords[i], count);
      }
    }
    if (updatedRecords.length > 0) {
      for (var j = 0; j < updatedRecords.length; j++) {
        putRecord(updatedRecords[j], count);
      }
    }
  }

  // POST new record on the server
  function postRecord(record, count) {
    var data = JSON.stringify(record);
    var xhr = new XMLHttpRequest();
    var resp;
    xhr.open('POST', url, true);
    xhr.setRequestHeader('Content-type','application/json; charset=utf-8');
    xhr.send(data);
    xhr.onload = function() {
      resp = JSON.parse(this.response);
      // Response have to containg `timestamp` generated on the server
      if (!resp.timestamp) {
        return handleError(new Error('No timestamp in POST response.'));
      }
      record.timestamp = resp.timestamp;
      updateRecord(record, count);
    };
    xhr.onerror = function(err) {
      handleError(err);
      count();
    };
  }

  // PUT updated record on the server
  function putRecord(record, count) {
    var data = JSON.stringify(record);
    var xhr = new XMLHttpRequest();
    var resp;
    xhr.open('PUT', url + '/' + record.id, true);
    xhr.setRequestHeader('Content-type','application/json; charset=utf-8');
    xhr.send(data);
    xhr.onload = function() {
      resp = JSON.parse(this.response);
      // Response have to contain new `timestamp` generated by the server
      if (!resp.timestamp) {
        return handleError(new Error('No timestamp in PUT response.'));
      }
      record.timestamp = resp.timestamp;
      updateRecord(record, count);
    };
    xhr.onerror = function(err) {
      handleError(err);
      count();
    };
  }

  // Update local record after successful sync
  function updateRecord(record, count) {
    db.open(function() {
      // Delete record only after server knows about the delete
      if (record.deleted) {
        db.delete(store, record.id, function(err, result) {
          db.close();
          count();
        });
      // Change state of the local record for next sync and do `count`
      } else {
        record.dirty = false;
        db.put(store, record, function(err, result) {
          db.close();
          count();
        });
      }
    });
  }

  // Dummy complete handler, should be replaced with `options.onComplete` paramater
  function syncComplete() {
    console.log('sync complete');
  }

  // Dummy error handler, should be repalced with `options.onError` parameter
  function handleError(err, count) {
    console.error(err.message);
    if (count) count();
  }

  // Counter for async operations
  function makeCounter(limit, db, callback) {
    if (limit === 0) return callback();
    var counter = limit;
    var count = function() {
      counter--;
      if (counter === 0) {
        // `db` or `null` have to be passed as second parameter
        if (db) {
          db.close();
        }
        return callback();
      }
    };
    return count;
  }

};
